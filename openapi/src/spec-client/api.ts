/* tslint:disable */
/* eslint-disable */
/**
 * PayBox
 * The Api collection for PayBox
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressType
 */
export interface AddressType {
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'eth'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'sol'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'bitcoin'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressType
     */
    'usdc'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Cluster = {
    Devnet: 'devnet',
    Testnet: 'testnet',
    MainnetBeta: 'mainnet-beta'
} as const;

export type Cluster = typeof Cluster[keyof typeof Cluster];


/**
 * 
 * @export
 * @interface CreateAddress200Response
 */
export interface CreateAddress200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateAddress200Response
     */
    'status'?: CreateAddress200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAddress200Response
     */
    'id'?: string;
}

export const CreateAddress200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type CreateAddress200ResponseStatusEnum = typeof CreateAddress200ResponseStatusEnum[keyof typeof CreateAddress200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreateClient
 */
export interface CreateClient {
    /**
     * 
     * @type {string}
     * @memberof CreateClient
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClient
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClient
     */
    'mobile'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateClient
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateClient
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateClient
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface DeleteClient200Response
 */
export interface DeleteClient200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteClient200Response
     */
    'status'?: DeleteClient200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DeleteClient200Response
     */
    'msg'?: DeleteClient200ResponseMsgEnum;
}

export const DeleteClient200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type DeleteClient200ResponseStatusEnum = typeof DeleteClient200ResponseStatusEnum[keyof typeof DeleteClient200ResponseStatusEnum];
export const DeleteClient200ResponseMsgEnum = {
    ClientDeleted: 'client deleted'
} as const;

export type DeleteClient200ResponseMsgEnum = typeof DeleteClient200ResponseMsgEnum[keyof typeof DeleteClient200ResponseMsgEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EthCluster = {
    Mainnet: 'mainnet',
    Ropsten: 'ropsten',
    Rinkeby: 'rinkeby',
    Goerli: 'goerli',
    Kovan: 'kovan',
    Sepolia: 'sepolia'
} as const;

export type EthCluster = typeof EthCluster[keyof typeof EthCluster];


/**
 * 
 * @export
 * @interface EthTxnResponse
 */
export interface EthTxnResponse {
    /**
     * Type of the transaction receipt
     * @type {string}
     * @memberof EthTxnResponse
     */
    '_type'?: string;
    /**
     * List of access lists
     * @type {Array<any>}
     * @memberof EthTxnResponse
     */
    'accessList'?: Array<any>;
    /**
     * The block number
     * @type {number}
     * @memberof EthTxnResponse
     */
    'blockNumber'?: number;
    /**
     * The block hash
     * @type {string}
     * @memberof EthTxnResponse
     */
    'blockHash'?: string;
    /**
     * The chain ID
     * @type {string}
     * @memberof EthTxnResponse
     */
    'chainId'?: string;
    /**
     * The transaction data
     * @type {string}
     * @memberof EthTxnResponse
     */
    'data'?: string;
    /**
     * The sender address
     * @type {string}
     * @memberof EthTxnResponse
     */
    'from'?: string;
    /**
     * The gas limit
     * @type {string}
     * @memberof EthTxnResponse
     */
    'gasLimit'?: string;
    /**
     * The gas price
     * @type {string}
     * @memberof EthTxnResponse
     */
    'gasPrice'?: string;
    /**
     * The transaction hash
     * @type {string}
     * @memberof EthTxnResponse
     */
    'hash'?: string;
    /**
     * The maximum fee per gas
     * @type {string}
     * @memberof EthTxnResponse
     */
    'maxFeePerGas'?: string;
    /**
     * The maximum priority fee per gas
     * @type {string}
     * @memberof EthTxnResponse
     */
    'maxPriorityFeePerGas'?: string;
    /**
     * The nonce
     * @type {number}
     * @memberof EthTxnResponse
     */
    'nonce'?: number;
    /**
     * 
     * @type {EthTxnResponseSignature}
     * @memberof EthTxnResponse
     */
    'signature'?: EthTxnResponseSignature;
    /**
     * The recipient address
     * @type {string}
     * @memberof EthTxnResponse
     */
    'to'?: string;
    /**
     * The transaction type
     * @type {number}
     * @memberof EthTxnResponse
     */
    'type'?: number;
    /**
     * The transaction value
     * @type {string}
     * @memberof EthTxnResponse
     */
    'value'?: string;
}
/**
 * The transaction signature
 * @export
 * @interface EthTxnResponseSignature
 */
export interface EthTxnResponseSignature {
    /**
     * Type of the signature
     * @type {string}
     * @memberof EthTxnResponseSignature
     */
    '_type'?: string;
    /**
     * Network version
     * @type {any}
     * @memberof EthTxnResponseSignature
     */
    'networkV'?: any;
    /**
     * The R value of the signature
     * @type {string}
     * @memberof EthTxnResponseSignature
     */
    'r'?: string;
    /**
     * The S value of the signature
     * @type {string}
     * @memberof EthTxnResponseSignature
     */
    's'?: string;
    /**
     * The V value of the signature
     * @type {number}
     * @memberof EthTxnResponseSignature
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface GetAddress302Response
 */
export interface GetAddress302Response {
    /**
     * 
     * @type {string}
     * @memberof GetAddress302Response
     */
    'status'?: GetAddress302ResponseStatusEnum;
    /**
     * 
     * @type {AddressType}
     * @memberof GetAddress302Response
     */
    'address'?: AddressType;
}

export const GetAddress302ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetAddress302ResponseStatusEnum = typeof GetAddress302ResponseStatusEnum[keyof typeof GetAddress302ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetMany200Response
 */
export interface GetMany200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMany200Response
     */
    'status'?: GetMany200ResponseStatusEnum;
    /**
     * 
     * @type {Array<TxnType>}
     * @memberof GetMany200Response
     */
    'txns'?: Array<TxnType>;
}

export const GetMany200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetMany200ResponseStatusEnum = typeof GetMany200ResponseStatusEnum[keyof typeof GetMany200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetManyTxnQueryParameter
 */
export interface GetManyTxnQueryParameter {
    /**
     * 
     * @type {GetManyTxnQueryParameterNetworks}
     * @memberof GetManyTxnQueryParameter
     */
    'networks'?: GetManyTxnQueryParameterNetworks;
    /**
     * Count representing the number of transactions required
     * @type {number}
     * @memberof GetManyTxnQueryParameter
     */
    'count'?: number;
}
/**
 * @type GetManyTxnQueryParameterNetworks
 * @export
 */
export type GetManyTxnQueryParameterNetworks = Array<Network> | Network;

/**
 * 
 * @export
 * @interface HealthCheck
 */
export interface HealthCheck {
    /**
     * 
     * @type {number}
     * @memberof HealthCheck
     */
    'uptime'?: number;
    /**
     * 
     * @type {string}
     * @memberof HealthCheck
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof HealthCheck
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface LoginClient
 */
export interface LoginClient {
    /**
     * 
     * @type {string}
     * @memberof LoginClient
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginClient
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'status'?: ModelErrorStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'msg'?: string;
}

export const ModelErrorStatusEnum = {
    Error: 'error'
} as const;

export type ModelErrorStatusEnum = typeof ModelErrorStatusEnum[keyof typeof ModelErrorStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const Network = {
    Sol: 'sol',
    Eth: 'eth',
    Bitcoin: 'bitcoin',
    Usdc: 'usdc'
} as const;

export type Network = typeof Network[keyof typeof Network];


/**
 * @type RegexAddress
 * @export
 */
export type RegexAddress = string;

/**
 * 
 * @export
 * @interface ReturnCreatedClient
 */
export interface ReturnCreatedClient {
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'jwt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'status'?: ReturnCreatedClientStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReturnCreatedClient
     */
    'mobile'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnCreatedClient
     */
    'password'?: string;
    /**
     * 
     * @type {object}
     * @memberof ReturnCreatedClient
     */
    'address'?: object | null;
}

export const ReturnCreatedClientStatusEnum = {
    Ok: 'ok',
    Error: 'error'
} as const;

export type ReturnCreatedClientStatusEnum = typeof ReturnCreatedClientStatusEnum[keyof typeof ReturnCreatedClientStatusEnum];

/**
 * 
 * @export
 * @interface Send200Response
 */
export interface Send200Response {
    /**
     * 
     * @type {string}
     * @memberof Send200Response
     */
    'status'?: Send200ResponseStatusEnum;
    /**
     * 
     * @type {Send200ResponseSignature}
     * @memberof Send200Response
     */
    'signature'?: Send200ResponseSignature;
}

export const Send200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type Send200ResponseStatusEnum = typeof Send200ResponseStatusEnum[keyof typeof Send200ResponseStatusEnum];

/**
 * @type Send200ResponseSignature
 * @export
 */
export type Send200ResponseSignature = EthTxnResponse | SolTransactionData;

/**
 * 
 * @export
 * @interface SendRequest
 */
export interface SendRequest {
    /**
     * 
     * @type {string}
     * @memberof SendRequest
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof SendRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof SendRequest
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof SendRequest
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface SolTransactionData
 */
export interface SolTransactionData {
    /**
     * Time at which the block was created
     * @type {number}
     * @memberof SolTransactionData
     */
    'blockTime'?: number;
    /**
     * 
     * @type {SolTransactionDataMeta}
     * @memberof SolTransactionData
     */
    'meta'?: SolTransactionDataMeta;
    /**
     * Slot number of the transaction
     * @type {number}
     * @memberof SolTransactionData
     */
    'slot'?: number;
    /**
     * 
     * @type {SolTransactionDataTransaction}
     * @memberof SolTransactionData
     */
    'transaction'?: SolTransactionDataTransaction;
}
/**
 * Metadata related to the transaction
 * @export
 * @interface SolTransactionDataMeta
 */
export interface SolTransactionDataMeta {
    /**
     * Number of compute units consumed
     * @type {number}
     * @memberof SolTransactionDataMeta
     */
    'computeUnitsConsumed'?: number;
    /**
     * Transaction fee
     * @type {number}
     * @memberof SolTransactionDataMeta
     */
    'fee'?: number;
    /**
     * Log messages related to the transaction
     * @type {Array<string>}
     * @memberof SolTransactionDataMeta
     */
    'logMessages'?: Array<string>;
    /**
     * Balances after the transaction
     * @type {Array<number>}
     * @memberof SolTransactionDataMeta
     */
    'postBalances'?: Array<number>;
    /**
     * Balances before the transaction
     * @type {Array<number>}
     * @memberof SolTransactionDataMeta
     */
    'preBalances'?: Array<number>;
    /**
     * 
     * @type {SolTransactionDataMetaStatus}
     * @memberof SolTransactionDataMeta
     */
    'status'?: SolTransactionDataMetaStatus;
}
/**
 * Status of the transaction
 * @export
 * @interface SolTransactionDataMetaStatus
 */
export interface SolTransactionDataMetaStatus {
    /**
     * 
     * @type {any}
     * @memberof SolTransactionDataMetaStatus
     */
    'Ok'?: any;
}
/**
 * Transaction details
 * @export
 * @interface SolTransactionDataTransaction
 */
export interface SolTransactionDataTransaction {
    /**
     * 
     * @type {SolTransactionDataTransactionMessage}
     * @memberof SolTransactionDataTransaction
     */
    'message'?: SolTransactionDataTransactionMessage;
    /**
     * Signatures of the transaction
     * @type {Array<string>}
     * @memberof SolTransactionDataTransaction
     */
    'signatures'?: Array<string>;
}
/**
 * Message details of the transaction
 * @export
 * @interface SolTransactionDataTransactionMessage
 */
export interface SolTransactionDataTransactionMessage {
    /**
     * 
     * @type {SolTransactionDataTransactionMessageHeader}
     * @memberof SolTransactionDataTransactionMessage
     */
    'header'?: SolTransactionDataTransactionMessageHeader;
    /**
     * Account keys involved in the transaction
     * @type {Array<string>}
     * @memberof SolTransactionDataTransactionMessage
     */
    'accountKeys'?: Array<string>;
    /**
     * Recent blockhash used in the transaction
     * @type {string}
     * @memberof SolTransactionDataTransactionMessage
     */
    'recentBlockhash'?: string;
    /**
     * Instructions for the transaction
     * @type {Array<SolTransactionDataTransactionMessageInstructionsInner>}
     * @memberof SolTransactionDataTransactionMessage
     */
    'instructions'?: Array<SolTransactionDataTransactionMessageInstructionsInner>;
}
/**
 * Header of the transaction message
 * @export
 * @interface SolTransactionDataTransactionMessageHeader
 */
export interface SolTransactionDataTransactionMessageHeader {
    /**
     * Number of readonly signed accounts
     * @type {number}
     * @memberof SolTransactionDataTransactionMessageHeader
     */
    'numReadonlySignedAccounts'?: number;
    /**
     * Number of readonly unsigned accounts
     * @type {number}
     * @memberof SolTransactionDataTransactionMessageHeader
     */
    'numReadonlyUnsignedAccounts'?: number;
    /**
     * Number of required signatures
     * @type {number}
     * @memberof SolTransactionDataTransactionMessageHeader
     */
    'numRequiredSignatures'?: number;
}
/**
 * 
 * @export
 * @interface SolTransactionDataTransactionMessageInstructionsInner
 */
export interface SolTransactionDataTransactionMessageInstructionsInner {
    /**
     * Accounts involved in the instruction
     * @type {Array<number>}
     * @memberof SolTransactionDataTransactionMessageInstructionsInner
     */
    'accounts'?: Array<number>;
    /**
     * Data for the instruction
     * @type {string}
     * @memberof SolTransactionDataTransactionMessageInstructionsInner
     */
    'data'?: string;
    /**
     * Index of the program ID
     * @type {number}
     * @memberof SolTransactionDataTransactionMessageInstructionsInner
     */
    'programIdIndex'?: number;
}
/**
 * 
 * @export
 * @interface TransactionSendQuery
 */
export interface TransactionSendQuery {
    /**
     * 
     * @type {RegexAddress}
     * @memberof TransactionSendQuery
     */
    'from'?: RegexAddress;
    /**
     * 
     * @type {RegexAddress}
     * @memberof TransactionSendQuery
     */
    'to'?: RegexAddress;
    /**
     * 
     * @type {string}
     * @memberof TransactionSendQuery
     */
    'amount'?: string;
    /**
     * 
     * @type {Network}
     * @memberof TransactionSendQuery
     */
    'network'?: Network;
}


/**
 * 
 * @export
 * @interface TxnGetQueryByHash
 */
export interface TxnGetQueryByHash {
    /**
     * 
     * @type {Network}
     * @memberof TxnGetQueryByHash
     */
    'network'?: Network;
    /**
     * 
     * @type {string}
     * @memberof TxnGetQueryByHash
     */
    'sign'?: string;
}


/**
 * 
 * @export
 * @interface TxnGetResponseByHash
 */
export interface TxnGetResponseByHash {
    /**
     * 
     * @type {string}
     * @memberof TxnGetResponseByHash
     */
    'status'?: TxnGetResponseByHashStatusEnum;
    /**
     * 
     * @type {TxnType}
     * @memberof TxnGetResponseByHash
     */
    'txn'?: TxnType;
}

export const TxnGetResponseByHashStatusEnum = {
    Ok: 'ok'
} as const;

export type TxnGetResponseByHashStatusEnum = typeof TxnGetResponseByHashStatusEnum[keyof typeof TxnGetResponseByHashStatusEnum];

/**
 * 
 * @export
 * @interface TxnType
 */
export interface TxnType {
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'clientId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxnType
     */
    'blockTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof TxnType
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TxnType
     */
    'fee'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'to'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TxnType
     */
    'postBalances'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof TxnType
     */
    'preBalances'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof TxnType
     */
    'recentBlockhash'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TxnType
     */
    'signature'?: Array<string>;
    /**
     * 
     * @type {Network}
     * @memberof TxnType
     */
    'network'?: Network;
    /**
     * 
     * @type {number}
     * @memberof TxnType
     */
    'slot'?: number;
    /**
     * 
     * @type {number}
     * @memberof TxnType
     */
    'chainId'?: number;
    /**
     * 
     * @type {TxnTypeCluster}
     * @memberof TxnType
     */
    'cluster'?: TxnTypeCluster;
}


/**
 * @type TxnTypeCluster
 * @export
 */
export type TxnTypeCluster = Cluster | EthCluster;

/**
 * 
 * @export
 * @interface UpdateMetadata200Response
 */
export interface UpdateMetadata200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetadata200Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetadata200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetadataRequest
 */
export interface UpdateMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetadataRequest
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetadataRequest
     */
    'lastname': string;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Address creation endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (authorization: string, addressType?: AddressType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createAddress', 'authorization', authorization)
            const localVarPath = `/address/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Address get endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAddress', 'authorization', authorization)
            const localVarPath = `/address/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Address update endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (authorization: string, addressType?: AddressType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('update', 'authorization', authorization)
            const localVarPath = `/address/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * Address creation endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(authorization: string, addressType?: AddressType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(authorization, addressType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.createAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Address get endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.getAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Address update endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(authorization: string, addressType?: AddressType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(authorization, addressType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * Address creation endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(authorization: string, addressType?: AddressType, options?: any): AxiosPromise<CreateAddress200Response> {
            return localVarFp.createAddress(authorization, addressType, options).then((request) => request(axios, basePath));
        },
        /**
         * Address get endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(authorization: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAddress(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Address update endpoint
         * @param {string} authorization Access token for authentication
         * @param {AddressType} [addressType] Address object that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(authorization: string, addressType?: AddressType, options?: any): AxiosPromise<CreateAddress200Response> {
            return localVarFp.update(authorization, addressType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * Address creation endpoint
     * @param {string} authorization Access token for authentication
     * @param {AddressType} [addressType] Address object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public createAddress(authorization: string, addressType?: AddressType, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).createAddress(authorization, addressType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Address get endpoint
     * @param {string} authorization Access token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public getAddress(authorization: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).getAddress(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Address update endpoint
     * @param {string} authorization Access token for authentication
     * @param {AddressType} [addressType] Address object that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public update(authorization: string, addressType?: AddressType, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).update(authorization, addressType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Client creation endpoint
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient: async (createClient?: CreateClient, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client delete endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteClient', 'authorization', authorization)
            const localVarPath = `/client/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client get endpoint
         * @param {string} authorization Access token for authentication
         * @param {string} username The username of the client to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient: async (authorization: string, username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getClient', 'authorization', authorization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getClient', 'username', username)
            const localVarPath = `/client/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client login endpoint
         * @param {LoginClient} [loginClient] Login Data for client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginClient?: LoginClient, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginClient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client jwt check endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('me', 'authorization', authorization)
            const localVarPath = `/client/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client creation or login endpoint for credentials from provider
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerAuth: async (createClient?: CreateClient, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/providerAuth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client metadata update endpoint
         * @param {string} authorization Access token for authentication
         * @param {UpdateMetadataRequest} [updateMetadataRequest] Client firstname lastname that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadata: async (authorization: string, updateMetadataRequest?: UpdateMetadataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateMetadata', 'authorization', authorization)
            const localVarPath = `/client/updateMetadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Client creation endpoint
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClient(createClient?: CreateClient, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnCreatedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClient(createClient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.createClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client delete endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClient(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteClient200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.deleteClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client get endpoint
         * @param {string} authorization Access token for authentication
         * @param {string} username The username of the client to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClient(authorization: string, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClient(authorization, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.getClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client login endpoint
         * @param {LoginClient} [loginClient] Login Data for client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginClient?: LoginClient, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginClient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client jwt check endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async me(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.me(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.me']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client creation or login endpoint for credentials from provider
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerAuth(createClient?: CreateClient, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnCreatedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerAuth(createClient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.providerAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Client metadata update endpoint
         * @param {string} authorization Access token for authentication
         * @param {UpdateMetadataRequest} [updateMetadataRequest] Client firstname lastname that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetadata(authorization: string, updateMetadataRequest?: UpdateMetadataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetadata(authorization, updateMetadataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.updateMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * Client creation endpoint
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(createClient?: CreateClient, options?: any): AxiosPromise<ReturnCreatedClient> {
            return localVarFp.createClient(createClient, options).then((request) => request(axios, basePath));
        },
        /**
         * Client delete endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(authorization: string, options?: any): AxiosPromise<DeleteClient200Response> {
            return localVarFp.deleteClient(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Client get endpoint
         * @param {string} authorization Access token for authentication
         * @param {string} username The username of the client to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(authorization: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.getClient(authorization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Client login endpoint
         * @param {LoginClient} [loginClient] Login Data for client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginClient?: LoginClient, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginClient, options).then((request) => request(axios, basePath));
        },
        /**
         * Client jwt check endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(authorization: string, options?: any): AxiosPromise<void> {
            return localVarFp.me(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Client creation or login endpoint for credentials from provider
         * @param {CreateClient} [createClient] Client object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerAuth(createClient?: CreateClient, options?: any): AxiosPromise<ReturnCreatedClient> {
            return localVarFp.providerAuth(createClient, options).then((request) => request(axios, basePath));
        },
        /**
         * Client metadata update endpoint
         * @param {string} authorization Access token for authentication
         * @param {UpdateMetadataRequest} [updateMetadataRequest] Client firstname lastname that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadata(authorization: string, updateMetadataRequest?: UpdateMetadataRequest, options?: any): AxiosPromise<UpdateMetadata200Response> {
            return localVarFp.updateMetadata(authorization, updateMetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * Client creation endpoint
     * @param {CreateClient} [createClient] Client object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public createClient(createClient?: CreateClient, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).createClient(createClient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client delete endpoint
     * @param {string} authorization Access token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public deleteClient(authorization: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).deleteClient(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client get endpoint
     * @param {string} authorization Access token for authentication
     * @param {string} username The username of the client to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getClient(authorization: string, username: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).getClient(authorization, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client login endpoint
     * @param {LoginClient} [loginClient] Login Data for client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public login(loginClient?: LoginClient, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).login(loginClient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client jwt check endpoint
     * @param {string} authorization Access token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public me(authorization: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).me(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client creation or login endpoint for credentials from provider
     * @param {CreateClient} [createClient] Client object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public providerAuth(createClient?: CreateClient, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).providerAuth(createClient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client metadata update endpoint
     * @param {string} authorization Access token for authentication
     * @param {UpdateMetadataRequest} [updateMetadataRequest] Client firstname lastname that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public updateMetadata(authorization: string, updateMetadataRequest?: UpdateMetadataRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).updateMetadata(authorization, updateMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * healthcheck endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/_health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * homepage endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * healthcheck endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.getHealthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * homepage endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async home(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.home(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.home']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * healthcheck endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: any): AxiosPromise<HealthCheck> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * homepage endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home(options?: any): AxiosPromise<HealthCheck> {
            return localVarFp.home(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * healthcheck endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getHealthCheck(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * homepage endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public home(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).home(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Transaction for client endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAll', 'authorization', authorization)
            const localVarPath = `/txn/getAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Transactions based on networks and count endpoint
         * @param {string} authorization Access token for authentication
         * @param {GetManyTxnQueryParameter} txnQuery Network/s and counts Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMany: async (authorization: string, txnQuery: GetManyTxnQueryParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMany', 'authorization', authorization)
            // verify required parameter 'txnQuery' is not null or undefined
            assertParamExists('getMany', 'txnQuery', txnQuery)
            const localVarPath = `/txn/getMany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txnQuery !== undefined) {
                for (const [key, value] of Object.entries(txnQuery)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transaction get by hash endpoint
         * @param {string} authorization Access token for authentication
         * @param {TxnGetQueryByHash} txnHash The Get Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxn: async (authorization: string, txnHash: TxnGetQueryByHash, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getTxn', 'authorization', authorization)
            // verify required parameter 'txnHash' is not null or undefined
            assertParamExists('getTxn', 'txnHash', txnHash)
            const localVarPath = `/txn/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txnHash !== undefined) {
                for (const [key, value] of Object.entries(txnHash)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transaction send endpoint
         * @param {string} authorization Access token for authentication
         * @param {TransactionSendQuery} transactionSend The Transaction query object
         * @param {SendRequest} [sendRequest] Transaction object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send: async (authorization: string, transactionSend: TransactionSendQuery, sendRequest?: SendRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('send', 'authorization', authorization)
            // verify required parameter 'transactionSend' is not null or undefined
            assertParamExists('send', 'transactionSend', transactionSend)
            const localVarPath = `/txn/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionSend !== undefined) {
                for (const [key, value] of Object.entries(transactionSend)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all Transaction for client endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Transactions based on networks and count endpoint
         * @param {string} authorization Access token for authentication
         * @param {GetManyTxnQueryParameter} txnQuery Network/s and counts Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMany(authorization: string, txnQuery: GetManyTxnQueryParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMany(authorization, txnQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.getMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transaction get by hash endpoint
         * @param {string} authorization Access token for authentication
         * @param {TxnGetQueryByHash} txnHash The Get Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxn(authorization: string, txnHash: TxnGetQueryByHash, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxnGetResponseByHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxn(authorization, txnHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.getTxn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transaction send endpoint
         * @param {string} authorization Access token for authentication
         * @param {TransactionSendQuery} transactionSend The Transaction query object
         * @param {SendRequest} [sendRequest] Transaction object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async send(authorization: string, transactionSend: TransactionSendQuery, sendRequest?: SendRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Send200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.send(authorization, transactionSend, sendRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.send']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Get all Transaction for client endpoint
         * @param {string} authorization Access token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(authorization: string, options?: any): AxiosPromise<GetMany200Response> {
            return localVarFp.getAll(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Transactions based on networks and count endpoint
         * @param {string} authorization Access token for authentication
         * @param {GetManyTxnQueryParameter} txnQuery Network/s and counts Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMany(authorization: string, txnQuery: GetManyTxnQueryParameter, options?: any): AxiosPromise<GetMany200Response> {
            return localVarFp.getMany(authorization, txnQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Transaction get by hash endpoint
         * @param {string} authorization Access token for authentication
         * @param {TxnGetQueryByHash} txnHash The Get Transaction query object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxn(authorization: string, txnHash: TxnGetQueryByHash, options?: any): AxiosPromise<TxnGetResponseByHash> {
            return localVarFp.getTxn(authorization, txnHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Transaction send endpoint
         * @param {string} authorization Access token for authentication
         * @param {TransactionSendQuery} transactionSend The Transaction query object
         * @param {SendRequest} [sendRequest] Transaction object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send(authorization: string, transactionSend: TransactionSendQuery, sendRequest?: SendRequest, options?: any): AxiosPromise<Send200Response> {
            return localVarFp.send(authorization, transactionSend, sendRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Get all Transaction for client endpoint
     * @param {string} authorization Access token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getAll(authorization: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getAll(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Transactions based on networks and count endpoint
     * @param {string} authorization Access token for authentication
     * @param {GetManyTxnQueryParameter} txnQuery Network/s and counts Transaction query object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getMany(authorization: string, txnQuery: GetManyTxnQueryParameter, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getMany(authorization, txnQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transaction get by hash endpoint
     * @param {string} authorization Access token for authentication
     * @param {TxnGetQueryByHash} txnHash The Get Transaction query object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getTxn(authorization: string, txnHash: TxnGetQueryByHash, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getTxn(authorization, txnHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transaction send endpoint
     * @param {string} authorization Access token for authentication
     * @param {TransactionSendQuery} transactionSend The Transaction query object
     * @param {SendRequest} [sendRequest] Transaction object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public send(authorization: string, transactionSend: TransactionSendQuery, sendRequest?: SendRequest, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).send(authorization, transactionSend, sendRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



